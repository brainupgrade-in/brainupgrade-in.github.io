<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Actions CI/CD Complete Guide: Master Docker, Kubernetes & KIND Automation (2026)</title>
    <meta name="description" content="Master GitHub Actions CI/CD with Docker and Kubernetes deployment. Complete guide with working examples, KIND integration, security best practices, and production workflows.">
    <meta name="keywords" content="github actions, ci cd, docker github actions, kubernetes github actions, kind deployment, github workflows, continuous integration, devops automation">
    <meta name="author" content="Rajesh Gheware">
    <link rel="canonical" href="https://devops.gheware.com/blog/posts/github-actions-cicd-guide-2026.html">
    <meta property="og:title" content="GitHub Actions CI/CD Complete Guide: Master Docker, Kubernetes & KIND Automation (2026)">
    <meta property="og:description" content="Master GitHub Actions CI/CD with Docker and Kubernetes deployment. Complete guide with working examples, KIND integration, security best practices, and production workflows.">
    <meta property="og:image" content="https://devops.gheware.com/images/github-actions-cicd-guide-2026.png">
    <meta property="og:url" content="https://devops.gheware.com/blog/posts/github-actions-cicd-guide-2026.html">
    <meta property="og:type" content="article">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="GitHub Actions CI/CD Complete Guide: Master Docker, Kubernetes & KIND Automation (2026)">
    <meta name="twitter:description" content="Master GitHub Actions CI/CD with Docker and Kubernetes deployment. Complete guide with working examples, KIND integration, security best practices, and production workflows.">
    <meta name="twitter:image" content="https://devops.gheware.com/images/github-actions-cicd-guide-2026.png">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.8;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f8f9fa;
        }
        .container {
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            font-size: 2.5rem;
            margin-bottom: 20px;
            line-height: 1.2;
        }
        h2 {
            color: #34495e;
            font-size: 1.8rem;
            margin-top: 30px;
            margin-bottom: 15px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        h3 {
            color: #34495e;
            font-size: 1.4rem;
            margin-top: 25px;
            margin-bottom: 12px;
        }
        .meta {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 30px;
            font-size: 0.95rem;
            border-left: 4px solid #3498db;
        }
        .highlight {
            background: #fff3cd;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        .warning {
            background: #f8d7da;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #dc3545;
            margin: 20px 0;
        }
        .success {
            background: #d1e7dd;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #28a745;
            margin: 20px 0;
        }
        pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Fira Code', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        code {
            background: #f1f3f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Fira Code', 'Courier New', monospace;
            color: #d63384;
            font-size: 0.9rem;
        }
        .cta {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 10px;
            text-align: center;
            margin: 30px 0;
        }
        .cta h3 {
            color: white;
            margin-top: 0;
        }
        .btn {
            display: inline-block;
            padding: 12px 25px;
            background: #28a745;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-weight: bold;
            transition: background 0.3s;
        }
        .btn:hover {
            background: #218838;
            text-decoration: none;
            color: white;
        }
        .author {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-top: 40px;
            border: 1px solid #dee2e6;
        }
        .toc {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #17a2b8;
        }
        .toc ul {
            margin: 0;
            padding-left: 20px;
        }
        .toc a {
            color: #495057;
            text-decoration: none;
        }
        .toc a:hover {
            color: #007bff;
            text-decoration: underline;
        }
        .faq {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 25px 0;
        }
        .faq-question {
            font-weight: bold;
            color: #495057;
            margin-bottom: 10px;
        }
        .faq-answer {
            color: #6c757d;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        .story-hook {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
            font-style: italic;
            box-shadow: 0 4px 15px rgba(240, 147, 251, 0.3);
        }
        ul, ol {
            padding-left: 25px;
        }
        li {
            margin-bottom: 8px;
        }
        .tip {
            background: #e7f3ff;
            border-left: 4px solid #007bff;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 5px 5px 0;
        }
        .key-takeaways {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 10px;
            margin: 25px 0;
        }
        .key-takeaways h3 {
            color: white;
            margin-top: 0;
        }
        .key-takeaways ul {
            margin: 0;
            padding-left: 20px;
        }
        .key-takeaways li {
            margin-bottom: 8px;
        }
    </style>
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Article",
        "headline": "GitHub Actions CI/CD Complete Guide: Master Docker, Kubernetes & KIND Automation (2026)",
        "author": {
            "@type": "Person",
            "name": "Rajesh Gheware",
            "url": "https://linkedin.com/in/rajesh-gheware"
        },
        "publisher": {
            "@type": "Organization",
            "name": "Gheware DevOps AI",
            "url": "https://devops.gheware.com"
        },
        "datePublished": "2026-01-24",
        "dateModified": "2026-01-24",
        "image": "https://devops.gheware.com/images/github-actions-cicd-guide-2026.png",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://devops.gheware.com/blog/posts/github-actions-cicd-guide-2026.html"
        }
    }
    </script>
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "FAQPage",
        "mainEntity": [
            {
                "@type": "Question",
                "name": "What are GitHub Actions and how do they work?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "GitHub Actions is a CI/CD platform that automates your build, test, and deployment pipeline. It uses YAML workflow files that define jobs triggered by repository events like pushes or pull requests."
                }
            },
            {
                "@type": "Question",
                "name": "How do I secure secrets in GitHub Actions workflows?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Use GitHub repository secrets (Settings > Secrets) to store sensitive data like API keys, passwords, and tokens. Access them in workflows using ${{ secrets.SECRET_NAME }} syntax."
                }
            },
            {
                "@type": "Question",
                "name": "Can I deploy to Kubernetes using GitHub Actions?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Yes! Use the kubectl action or Azure/k8s-deploy action to deploy to Kubernetes clusters. Store kubeconfig as a secret and authenticate using service accounts."
                }
            },
            {
                "@type": "Question",
                "name": "What is KIND and why use it in CI/CD?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "KIND (Kubernetes IN Docker) creates lightweight Kubernetes clusters for testing. It's perfect for validating Kubernetes manifests and running integration tests in CI pipelines."
                }
            },
            {
                "@type": "Question",
                "name": "How can I optimize GitHub Actions workflow performance?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Use caching for dependencies, run jobs in parallel, use self-hosted runners for better performance, and optimize Docker layer caching with buildx."
                }
            },
            {
                "@type": "Question",
                "name": "What are the GitHub Actions usage limits?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Free accounts get 2,000 minutes/month for private repos (unlimited for public). Pro accounts get 3,000 minutes/month. Each job can run up to 6 hours maximum."
                }
            },
            {
                "@type": "Question",
                "name": "How do I handle environment-specific deployments in GitHub Actions?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Use GitHub Environments to define deployment rules, required reviewers, and environment-specific secrets. Configure different workflows for staging, production, etc."
                }
            }
        ]
    }
    </script>
</head>
<body>
    <div class="container">
        <div class="meta">
            <strong>Published:</strong> January 24, 2026 |
            <strong>Author:</strong> Rajesh Gheware |
            <strong>Reading Time:</strong> 18 minutes |
            <strong>Last Updated:</strong> January 24, 2026
        </div>

        <h1>GitHub Actions CI/CD Complete Guide: Master Docker, Kubernetes & KIND Automation (2026)</h1>

        <div class="story-hook">
            üö® <strong>The $2M Deploy Disaster:</strong> A Fortune 500 company I consulted for was manually deploying to production every Friday at 5 PM. One typo in a kubectl command brought down their entire e-commerce platform during peak shopping hours. $2 million in lost revenue. The CTO asked me one simple question: "How do we make sure this NEVER happens again?" The answer? Bulletproof CI/CD with GitHub Actions. Let me show you how to build deployment pipelines so robust, even your worst Friday afternoon mistakes can't break production.
        </div>

        <div class="key-takeaways">
            <h3>üéØ What You'll Master Today</h3>
            <ul>
                <li><strong>Complete GitHub Actions setup</strong> from zero to production-ready pipelines</li>
                <li><strong>Docker integration</strong> with automated image building, scanning, and registry push</li>
                <li><strong>Kubernetes deployment</strong> with KIND testing and production rollouts</li>
                <li><strong>Security best practices</strong> for secrets management and vulnerability scanning</li>
                <li><strong>Advanced optimization</strong> techniques for faster, more reliable deployments</li>
            </ul>
        </div>

        <div class="toc">
            <h3>üìã Table of Contents</h3>
            <ul>
                <li><a href="#what-are-github-actions">What Are GitHub Actions?</a></li>
                <li><a href="#setting-up-workflow">Setting Up Your First Workflow</a></li>
                <li><a href="#docker-integration">Docker Integration & Registry Push</a></li>
                <li><a href="#kind-testing">KIND Testing for Kubernetes</a></li>
                <li><a href="#kubernetes-deployment">Production Kubernetes Deployment</a></li>
                <li><a href="#security-best-practices">Security Best Practices</a></li>
                <li><a href="#advanced-patterns">Advanced Workflow Patterns</a></li>
                <li><a href="#troubleshooting">Troubleshooting Common Issues</a></li>
                <li><a href="#faq">Frequently Asked Questions</a></li>
            </ul>
        </div>

        <h2 id="what-are-github-actions">üöÄ What Are GitHub Actions?</h2>

        <p>GitHub Actions is a powerful CI/CD platform that automates your software development workflow directly within your GitHub repository. It's like having a dedicated DevOps engineer that <strong>never sleeps, never makes mistakes, and works for free</strong>.</p>

        <div class="highlight">
            <p><strong>üéØ Real-World Impact:</strong> Teams using GitHub Actions report 85% faster deployment cycles, 90% reduction in deployment errors, and 40% less time spent on manual testing compared to traditional CI/CD tools.</p>
        </div>

        <h3>Core Components</h3>

        <ul>
            <li><strong>Workflows:</strong> Automated processes defined in YAML files</li>
            <li><strong>Jobs:</strong> Sets of steps that run on the same runner</li>
            <li><strong>Steps:</strong> Individual tasks like running commands or using actions</li>
            <li><strong>Actions:</strong> Reusable units of code (your own or from marketplace)</li>
            <li><strong>Runners:</strong> Virtual machines that execute your workflows</li>
        </ul>

        <h3>Why Choose GitHub Actions for CI/CD?</h3>

        <div class="success">
            <p><strong>‚úÖ Advantages Over Traditional CI/CD:</strong></p>
            <ul>
                <li><strong>Native Integration:</strong> Built into GitHub, no external tools needed</li>
                <li><strong>Zero Configuration:</strong> Works out-of-the-box with any repository</li>
                <li><strong>Massive Marketplace:</strong> 10,000+ pre-built actions available</li>
                <li><strong>Cost-Effective:</strong> 2,000 free minutes/month for private repos</li>
                <li><strong>Parallel Execution:</strong> Run multiple jobs simultaneously</li>
                <li><strong>Matrix Builds:</strong> Test across multiple environments automatically</li>
            </ul>
        </div>

        <h2 id="setting-up-workflow">‚öôÔ∏è Setting Up Your First Workflow</h2>

        <p>Let's build a complete CI/CD pipeline for a real-world application. I'll use a Python weather application as our example, but the patterns apply to any technology stack.</p>

        <h3>Project Structure</h3>
        <pre><code>weather-py/
‚îú‚îÄ‚îÄ .github/
‚îÇ   ‚îî‚îÄ‚îÄ workflows/
‚îÇ       ‚îî‚îÄ‚îÄ ci-cd.yml          # Main workflow file
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ main.py               # Flask application
‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt      # Dependencies
‚îú‚îÄ‚îÄ k8s/
‚îÇ   ‚îú‚îÄ‚îÄ deployment.yaml       # Kubernetes manifest
‚îÇ   ‚îú‚îÄ‚îÄ service.yaml         # Service definition
‚îÇ   ‚îî‚îÄ‚îÄ ingress.yaml         # Ingress configuration
‚îú‚îÄ‚îÄ Dockerfile               # Container image definition
‚îî‚îÄ‚îÄ README.md</code></pre>

        <h3>Basic Workflow Structure</h3>

        <p>Create <code>.github/workflows/ci-cd.yml</code> in your repository:</p>

        <pre><code>name: CI/CD Pipeline

# Trigger conditions
on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  # Manual trigger
  workflow_dispatch:

# Environment variables available to all jobs
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Job 1: Code Quality & Testing
  test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.9'
        cache: 'pip'  # Cache pip dependencies

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r app/requirements.txt
        pip install pytest flake8 black

    - name: Code formatting check
      run: black --check app/

    - name: Lint code
      run: flake8 app/

    - name: Run unit tests
      run: |
        cd app
        python -m pytest tests/ -v --junitxml=../test-results.xml

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: test-results.xml</code></pre>

        <h3>Workflow Triggers Explained</h3>

        <div class="tip">
            <p><strong>üí° Pro Tip:</strong> Use different triggers for different environments:</p>
            <ul>
                <li><strong>push to main:</strong> Deploy to production</li>
                <li><strong>push to develop:</strong> Deploy to staging</li>
                <li><strong>pull_request:</strong> Run tests only</li>
                <li><strong>workflow_dispatch:</strong> Manual deployments</li>
                <li><strong>schedule:</strong> Nightly builds and security scans</li>
            </ul>
        </div>

        <h2 id="docker-integration">üê≥ Docker Integration & Registry Push</h2>

        <p>Let's add Docker image building and push to our workflow. This creates a portable, consistent deployment artifact.</p>

        <h3>Dockerfile Best Practices</h3>

        <p>First, create an optimized Dockerfile for our Python app:</p>

        <pre><code># Use specific version for reproducibility
FROM python:3.9-slim-buster

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements first (better layer caching)
COPY app/requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Create non-root user for security
RUN adduser --disabled-password --gecos '' appuser

# Copy application code
COPY app/ .

# Change ownership to non-root user
RUN chown -R appuser:appuser /app
USER appuser

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:5000/health || exit 1

# Expose port
EXPOSE 5000

# Run application
CMD ["python", "main.py"]</code></pre>

        <h3>Docker Build & Push Job</h3>

        <p>Add this job to your workflow file:</p>

        <pre><code>  # Job 2: Build and Push Docker Image
  build:
    needs: test  # Only run if tests pass
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.tags }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        # Multi-platform builds
        platforms: linux/amd64,linux/arm64</code></pre>

        <h3>Docker Security Scanning</h3>

        <p>Add vulnerability scanning to catch security issues early:</p>

        <pre><code>    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'</code></pre>

        <h2 id="kind-testing">üß™ KIND Testing for Kubernetes</h2>

        <p>Kubernetes IN Docker (KIND) creates lightweight local clusters perfect for testing your Kubernetes manifests in CI.</p>

        <h3>KIND Integration Job</h3>

        <pre><code>  # Job 3: Kubernetes Testing with KIND
  k8s-test:
    needs: build
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Create KIND cluster
      uses: helm/kind-action@v1.8.0
      with:
        cluster_name: test-cluster
        node_image: kindest/node:v1.29.0
        config: |
          kind: Cluster
          apiVersion: kind.x-k8s.io/v1alpha4
          nodes:
          - role: control-plane
            kubeadmConfigPatches:
            - |
              kind: InitConfiguration
              nodeRegistration:
                kubeletExtraArgs:
                  node-labels: "ingress-ready=true"
            extraPortMappings:
            - containerPort: 80
              hostPort: 80
              protocol: TCP
            - containerPort: 443
              hostPort: 443
              protocol: TCP

    - name: Load Docker image into KIND
      run: |
        # Get image from previous job
        IMAGE_TAG="${{ needs.build.outputs.image-tag }}"
        echo "Loading image: $IMAGE_TAG"

        # Pull image (since it was built in previous job)
        docker pull $IMAGE_TAG

        # Load image into KIND cluster
        kind load docker-image $IMAGE_TAG --name test-cluster

    - name: Install NGINX Ingress Controller
      run: |
        kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml
        kubectl wait --namespace ingress-nginx \
          --for=condition=ready pod \
          --selector=app.kubernetes.io/component=controller \
          --timeout=90s

    - name: Deploy application to KIND
      run: |
        # Update image tag in deployment
        sed -i "s|IMAGE_TAG|${{ needs.build.outputs.image-tag }}|g" k8s/deployment.yaml

        # Apply all Kubernetes manifests
        kubectl apply -f k8s/

        # Wait for deployment to be ready
        kubectl wait --for=condition=available --timeout=300s deployment/weather-app

    - name: Run integration tests
      run: |
        # Port forward to access the app
        kubectl port-forward svc/weather-app 8080:80 &
        sleep 10

        # Test health endpoint
        curl -f http://localhost:8080/health || exit 1

        # Test weather API
        curl -f "http://localhost:8080/weather?city=London" || exit 1

        echo "‚úÖ All integration tests passed!"

    - name: Debug on failure
      if: failure()
      run: |
        echo "=== Pod Status ==="
        kubectl get pods -o wide

        echo "=== Pod Logs ==="
        kubectl logs -l app=weather-app

        echo "=== Events ==="
        kubectl get events --sort-by=.metadata.creationTimestamp</code></pre>

        <div class="warning">
            <p><strong>‚ö†Ô∏è Common KIND Pitfall:</strong> KIND clusters use Docker-in-Docker, so images built in previous jobs need to be explicitly loaded using <code>kind load docker-image</code>. Don't forget this step!</p>
        </div>

        <h2 id="kubernetes-deployment">‚ò∏Ô∏è Production Kubernetes Deployment</h2>

        <p>Now let's deploy to a real Kubernetes cluster. This example shows deployment to multiple environments.</p>

        <h3>Environment-Specific Deployment</h3>

        <pre><code>  # Job 4: Deploy to Staging
  deploy-staging:
    needs: [build, k8s-test]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment: staging

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure kubectl
      run: |
        echo "${{ secrets.STAGING_KUBECONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=./kubeconfig

    - name: Deploy to staging
      run: |
        # Update image tag
        sed -i "s|IMAGE_TAG|${{ needs.build.outputs.image-tag }}|g" k8s/deployment.yaml

        # Apply to staging namespace
        kubectl apply -f k8s/ -n staging

        # Wait for rollout to complete
        kubectl rollout status deployment/weather-app -n staging --timeout=600s

        # Verify deployment
        kubectl get pods -n staging -l app=weather-app

  # Job 5: Deploy to Production
  deploy-production:
    needs: [build, k8s-test]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://weather.company.com

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure kubectl
      run: |
        echo "${{ secrets.PROD_KUBECONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=./kubeconfig

    - name: Blue-Green Deployment
      run: |
        # Update image tag
        sed -i "s|IMAGE_TAG|${{ needs.build.outputs.image-tag }}|g" k8s/deployment.yaml

        # Create new deployment with version label
        kubectl apply -f k8s/ -n production

        # Wait for new version to be ready
        kubectl rollout status deployment/weather-app -n production --timeout=600s

        # Run smoke tests
        ./scripts/smoke-tests.sh production

        # Update service to point to new version (if using blue-green)
        kubectl patch service weather-app -n production -p '{"spec":{"selector":{"version":"'${{ github.sha }}'"}}}'

    - name: Notify deployment success
      uses: 8398a7/action-slack@v3
      with:
        status: success
        text: '‚úÖ Production deployment successful! Version: ${{ github.sha }}'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}</code></pre>

        <h3>Kubernetes Manifests</h3>

        <p>Here are the production-ready Kubernetes manifests:</p>

        <pre><code># k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: weather-app
  labels:
    app: weather-app
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app: weather-app
  template:
    metadata:
      labels:
        app: weather-app
        version: ${{ github.sha }}
    spec:
      containers:
      - name: weather-app
        image: IMAGE_TAG  # Replaced by CI/CD
        ports:
        - containerPort: 5000
        env:
        - name: ENV
          value: production
        - name: API_KEY
          valueFrom:
            secretKeyRef:
              name: weather-secrets
              key: api-key
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        livenessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 5000
          initialDelaySeconds: 5
          periodSeconds: 5
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
          allowPrivilegeEscalation: false</code></pre>

        <h2 id="security-best-practices">üîí Security Best Practices</h2>

        <p>Security should be built into every step of your CI/CD pipeline. Here are essential practices for GitHub Actions.</p>

        <h3>Secrets Management</h3>

        <div class="success">
            <p><strong>‚úÖ Secrets Best Practices:</strong></p>
            <ul>
                <li><strong>Repository Secrets:</strong> Use Settings > Secrets for API keys, passwords</li>
                <li><strong>Environment Secrets:</strong> Different secrets for staging/production</li>
                <li><strong>Least Privilege:</strong> Grant minimal necessary permissions</li>
                <li><strong>Secret Rotation:</strong> Regularly update and rotate sensitive credentials</li>
                <li><strong>No Hardcoding:</strong> Never commit secrets to code</li>
            </ul>
        </div>

        <h3>Secure Workflow Configuration</h3>

        <pre><code>name: Secure CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

# Restrict permissions by default
permissions:
  contents: read

jobs:
  secure-build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      security-events: write  # For SARIF uploads

    steps:
    - name: Harden Runner
      uses: step-security/harden-runner@v2
      with:
        egress-policy: audit
        disable-sudo: true
        disable-file-monitoring: false

    - name: Checkout code
      uses: actions/checkout@v4
      with:
        persist-credentials: false  # Don't persist git credentials

    - name: Dependency Review
      uses: actions/dependency-review-action@v4
      if: github.event_name == 'pull_request'

    - name: Run CodeQL Analysis
      uses: github/codeql-action/init@v3
      with:
        languages: python

    - name: Build application
      run: |
        # Your build commands here
        python -m pip install -r requirements.txt

    - name: Run CodeQL Analysis
      uses: github/codeql-action/analyze@v3</code></pre>

        <h3>Container Security</h3>

        <pre><code>    - name: Build Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: false
        tags: temp-image:latest
        # Security optimizations
        build-args: |
          BUILDKIT_INLINE_CACHE=1
        secrets: |
          GIT_AUTH_TOKEN=${{ secrets.GITHUB_TOKEN }}

    - name: Run container security scan
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: 'temp-image:latest'
        format: 'sarif'
        output: 'trivy-results.sarif'
        severity: 'CRITICAL,HIGH'
        exit-code: '1'  # Fail build on critical vulnerabilities

    - name: Run Snyk container scan
      uses: snyk/actions/docker@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      with:
        image: temp-image:latest
        args: --severity-threshold=high</code></pre>

        <div class="tip">
            <p><strong>üîê Security Tip:</strong> Use GitHub's <strong>dependency review action</strong> to automatically scan for vulnerable dependencies in pull requests. This catches security issues before they reach your main branch.</p>
        </div>

        <h2 id="advanced-patterns">üöÄ Advanced Workflow Patterns</h2>

        <h3>Matrix Builds for Multiple Environments</h3>

        <p>Test your application across multiple versions and configurations:</p>

        <pre><code>jobs:
  test-matrix:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.8, 3.9, '3.10', 3.11]
        django-version: [3.2, 4.0, 4.1]
        exclude:
          # Exclude unsupported combinations
          - python-version: 3.8
            django-version: 4.1

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}

    - name: Install Django ${{ matrix.django-version }}
      run: |
        pip install Django==${{ matrix.django-version }}
        pip install -r requirements.txt

    - name: Run tests
      run: python manage.py test</code></pre>

        <h3>Conditional Deployments with Approval</h3>

        <pre><code>jobs:
  deploy:
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://app.company.com
    # Only deploy on main branch AND if version tag exists
    if: github.ref == 'refs/heads/main' && contains(github.event.head_commit.message, '[deploy]')

    steps:
    - name: Wait for approval
      uses: trstringer/manual-approval@v1
      with:
        secret: ${{ secrets.GITHUB_TOKEN }}
        approvers: rajesh,devops-team
        minimum-approvals: 2
        issue-title: "Deploy version ${{ github.sha }} to production"
        issue-body: |
          Please review the changes and approve deployment:

          **Commit**: ${{ github.sha }}
          **Author**: ${{ github.actor }}
          **Changes**: ${{ github.event.head_commit.message }}

          [View Changes](https://github.com/${{ github.repository }}/commit/${{ github.sha }})

    - name: Deploy to production
      run: |
        echo "Deploying to production..."
        # Your deployment steps here</code></pre>

        <h3>Workflow Optimization Techniques</h3>

        <div class="highlight">
            <p><strong>üöÄ Performance Optimizations:</strong></p>
            <ul>
                <li><strong>Caching:</strong> Cache dependencies, Docker layers, and build artifacts</li>
                <li><strong>Parallel Jobs:</strong> Run independent jobs simultaneously</li>
                <li><strong>Early Termination:</strong> Fail fast on critical errors</li>
                <li><strong>Artifact Management:</strong> Share build outputs between jobs efficiently</li>
                <li><strong>Self-Hosted Runners:</strong> Use for better performance and cost control</li>
            </ul>
        </div>

        <h2 id="troubleshooting">üîß Troubleshooting Common Issues</h2>

        <h3>1. Workflow Not Triggering</h3>

        <div class="warning">
            <p><strong>Symptoms:</strong> Workflow file exists but doesn't run on push/PR</p>
        </div>

        <p><strong>Common Causes & Solutions:</strong></p>
        <ul>
            <li><strong>YAML Syntax Error:</strong> Use GitHub's workflow editor for validation</li>
            <li><strong>Wrong Branch Name:</strong> Check trigger branch names match exactly</li>
            <li><strong>File Location:</strong> Must be in <code>.github/workflows/</code> directory</li>
            <li><strong>Permissions:</strong> Check repository settings allow Actions</li>
        </ul>

        <pre><code># Debug workflow triggers
name: Debug Workflow
on:
  push:
  pull_request:
  workflow_dispatch:  # Add manual trigger for testing

jobs:
  debug:
    runs-on: ubuntu-latest
    steps:
    - name: Print trigger info
      run: |
        echo "Event: ${{ github.event_name }}"
        echo "Ref: ${{ github.ref }}"
        echo "Actor: ${{ github.actor }}"</code></pre>

        <h3>2. Docker Build Failures</h3>

        <p><strong>Debug Docker issues systematically:</strong></p>
        <pre><code>- name: Debug Docker build
  if: failure()
  run: |
    echo "=== Docker Info ==="
    docker version
    docker system df

    echo "=== Build Context ==="
    ls -la

    echo "=== Dockerfile Content ==="
    cat Dockerfile

    echo "=== Available Space ==="
    df -h</code></pre>

        <h3>3. Kubernetes Deployment Issues</h3>

        <p><strong>Comprehensive K8s debugging:</strong></p>
        <pre><code>- name: Debug Kubernetes deployment
  if: failure()
  run: |
    echo "=== Cluster Info ==="
    kubectl cluster-info

    echo "=== Nodes Status ==="
    kubectl get nodes -o wide

    echo "=== Pod Status ==="
    kubectl get pods -A

    echo "=== Recent Events ==="
    kubectl get events --sort-by=.metadata.creationTimestamp

    echo "=== Deployment Logs ==="
    kubectl logs deployment/weather-app -n default --tail=100</code></pre>

        <div class="cta">
            <h3>üéØ Want to Master DevOps Automation?</h3>
            <p>Join 10,000+ engineers building bulletproof CI/CD pipelines. Get our complete GitHub Actions template library and advanced Kubernetes deployment strategies.</p>
            <a href="training/cloud-labs.html/github-actions-mastery" class="btn">Get Free Templates ‚Üí</a>
        </div>

        <div class="tip">
            <p><strong>üí¨ Share Your Experience:</strong> Have you built GitHub Actions workflows for production? What challenges did you face? Share your insights in the comments below!</p>
        </div>

        <h2 id="faq">‚ùì Frequently Asked Questions</h2>

        <div class="faq">
            <div class="faq-question">Q: What are GitHub Actions and how do they work?</div>
            <div class="faq-answer">A: GitHub Actions is a CI/CD platform that automates your build, test, and deployment pipeline. It uses YAML workflow files that define jobs triggered by repository events like pushes or pull requests.</div>

            <div class="faq-question">Q: How do I secure secrets in GitHub Actions workflows?</div>
            <div class="faq-answer">A: Use GitHub repository secrets (Settings > Secrets) to store sensitive data like API keys, passwords, and tokens. Access them in workflows using ${{ secrets.SECRET_NAME }} syntax.</div>

            <div class="faq-question">Q: Can I deploy to Kubernetes using GitHub Actions?</div>
            <div class="faq-answer">A: Yes! Use the kubectl action or Azure/k8s-deploy action to deploy to Kubernetes clusters. Store kubeconfig as a secret and authenticate using service accounts.</div>

            <div class="faq-question">Q: What is KIND and why use it in CI/CD?</div>
            <div class="faq-answer">A: KIND (Kubernetes IN Docker) creates lightweight Kubernetes clusters for testing. It's perfect for validating Kubernetes manifests and running integration tests in CI pipelines.</div>

            <div class="faq-question">Q: How can I optimize GitHub Actions workflow performance?</div>
            <div class="faq-answer">A: Use caching for dependencies, run jobs in parallel, use self-hosted runners for better performance, and optimize Docker layer caching with buildx.</div>

            <div class="faq-question">Q: What are the GitHub Actions usage limits?</div>
            <div class="faq-answer">A: Free accounts get 2,000 minutes/month for private repos (unlimited for public). Pro accounts get 3,000 minutes/month. Each job can run up to 6 hours maximum.</div>

            <div class="faq-question">Q: How do I handle environment-specific deployments in GitHub Actions?</div>
            <div class="faq-answer">A: Use GitHub Environments to define deployment rules, required reviewers, and environment-specific secrets. Configure different workflows for staging, production, etc.</div>
        </div>

        <p><strong>üé¨ Watch the Tutorial:</strong> See this GitHub Actions CI/CD pipeline in action with our <a href="https://youtube.com/watch?v=VIDEO_ID">complete video walkthrough</a>.</p>

        <div class="author">
            <h3>About the Author</h3>
            <p><strong>Rajesh Gheware</strong> is a Senior DevOps Architect with over 20 years of experience building enterprise CI/CD pipelines. He has helped Fortune 500 companies migrate from manual deployments to fully automated GitHub Actions workflows, reducing deployment times from hours to minutes.</p>
            <p>Connect with Rajesh: <a href="https://linkedin.com/in/rajesh-gheware">LinkedIn</a> | <a href="https://github.com/brainupgrade-in">GitHub</a></p>
        </div>
    </div>
</body>
</html>